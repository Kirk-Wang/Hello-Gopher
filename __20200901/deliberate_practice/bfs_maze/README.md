åˆ»æ„ç»ƒä¹ ï¼Œè¶…å®¹æ˜“ç†è§£çš„ Golang BFS èµ°è¿·å®«

## ä»‹ç»

ç¼–ç æ€ç»´è®­ç»ƒï¼Œä¸è®­ç»ƒå°±ç§€é€—äº†ğŸ¶ğŸ¶ã€‚

è¿™ä¼šæ˜¯ä¸€ä¸ªç³»åˆ—ã€‚

## The Mazeï¼ˆè¿·å®«ï¼‰

ä¸‹é¢æ˜¯ä¸€ä¸ª `6` è¡Œ `5` åˆ—çš„äºŒç»´é˜µåˆ—ï¼Œç”¨æ¥è¡¨ç¤ºè¿·å®«ã€‚

* `0` ä»£è¡¨å¯ä»¥é€šè¡Œ
* `1` è¡¨ç¤ºä¸èƒ½é€šè¡Œ

æˆ‘|æ˜¯|è¿·|å®«|å®«
-|-|-|-|-
0|1|0|0|0
0|0|0|1|0
0|1|0|1|0
1|1|1|0|0
0|1|0|0|1
0|1|0|0|0

æˆ‘ä»¬æ˜¯ä½¿ç”¨ä¸€ä¸ªäºŒç»´ `slice` æ¥è¡¨ç¤ºå®ƒã€‚

```go
maze := [][]int {
  {0, 1, 0, 0, 0},
  {0, 0, 0, 1, 0},
  {0, 1, 0, 1, 0},
  {1, 1, 1, 0, 0},
  {0, 1, 0, 0, 1},
  {0, 1, 0, 0, 0},
}
```

æ—¢ç„¶æ˜¯èµ°è¿·å®«ï¼Œå¿…å®šæœ‰`å…¥å£`ã€`å‡ºå£`ã€å’Œå¯ä»¥æ¢ç´¢å‡ºå£çš„`æ–¹å‘`ã€‚

è¿™é‡Œè®¾å®šï¼š
* `å…¥å£` æ˜¯äºŒç»´æ•°ç»„åæ ‡ `(0, 0)`
* `å‡ºå£` æ˜¯äºŒç»´æ•°ç»„åæ ‡ `(5, 4)`
* `æ–¹å‘` æ˜¯ `ä¸Š`ã€`ä¸‹`ã€`å·¦`ã€`å³`

### å¦‚ä½•ä»å…¥å£èµ°åˆ°å‡ºå£å‘¢ï¼Ÿ

æƒ³è±¡è‡ªå·±è¢«æ‰”åœ¨ä¸€ä¸ªæœªçŸ¥çš„ç‚¹ï¼Œæˆ‘ä»¬å…è®¸åœ¨è¿™ä¸€ç‚¹çš„ä¸Šã€ä¸‹ã€å·¦ã€å³`å››`ä¸ªæ–¹å‘å»æ¢ç´¢ã€‚

é€šè¿‡`1`æ­¥ï¼Œèƒ½èµ°åˆ°çš„æ ¼å­æ˜¯`4`ä¸ªã€‚

```
  1
1 0 1
  1
```

é€šè¿‡`2`æ­¥ï¼Œèƒ½èµ°åˆ°çš„æ ¼å­æ˜¯`8`ä¸ªã€‚

```
    2
  2 1 2
2 1 0 1 2
  2 1 2
    2
```

é€šè¿‡`3`æ­¥ï¼Œèƒ½èµ°åˆ°çš„æ ¼å­æ˜¯`12`ä¸ªã€‚

```
      3
    3 2 3
  3 2 1 2 3
3 2 1 0 1 2 3
  3 2 1 2 3
    3 2 3
      3
```

é€šè¿‡`n`æ­¥ï¼Œèƒ½èµ°åˆ°çš„æ ¼å­æ˜¯`n*4(æ–¹å‘)`ä¸ªã€‚

å½“å‰è¿™ä¸€æ­¥ï¼Œæˆ–è€…è¯´å½“å‰è¿™ä¸€ç‚¹çš„çŠ¶æ€å°±æœ‰å¦‚ä¸‹ï¼š
* å·²ç»å‘ç°ä½†è¿˜æ²¡æœ‰æ¢ç´¢ï¼ˆæ’é˜Ÿï¼‰
* å·²ç»æ¢ç´¢
* å‘éƒ½è¿˜æ²¡æœ‰å‘ç°

`1`(4ä¸ªæ–¹å‘) æ¢ç´¢å®Œäº†æ‰è½®åˆ° `2`ï¼Œæ˜¯ä¸€ä¸ªå¾ˆè‡ªç„¶çš„æ’é˜Ÿè¿‡ç¨‹ã€‚

ä¸€å±‚ä¸€å±‚çš„å¾€å¤–é€’è¿›ï¼Œç¡®ä¿æ¯åˆ°ä¸€ä¸ªç‚¹éƒ½æ˜¯ä¸€ä¸ªæœ€çŸ­çš„è·¯å¾„åˆ°çš„è¿™ä¸ªç‚¹ã€‚

**åº”ç”¨ï¼š**

æ³¨æ„ï¼š**å†™ç¨‹åºçš„æ—¶å€™ä¸Šã€å·¦ã€ä¸‹ã€å³ã€‚é€†æ—¶é’ˆ 90Â°ï¼Œ90Â°çš„è½¬ã€‚å¯èƒ½ä¼šå¸¦æ¥ä¸€äº›å¥½å¤„ã€‚**

1. ç©ºæŠ•åˆ°äº†ä¸€ä¸ªç‚¹`(0, 0)`ï¼Œ0 æ­¥è¢«èµ°åˆ°ã€‚å…¶å®ƒçš„å„è‡ªæ˜¯æœªçŸ¥çš„ï¼Œè¿·å®«é•¿å•¥æ ·ä¹Ÿæ˜¯æœªçŸ¥çš„ã€‚
  * çŠ¶æ€ï¼šå·²ç»å‘ç°ä½†è¿˜æ²¡æœ‰æ¢ç´¢ï¼ˆ`æ’é˜Ÿ`->ä¹Ÿå°±æ˜¯é¦–å…ˆå°† `(0, 0)`ï¼‰
2. å¼€å§‹æ¢ç´¢ (0, 0)--> ä¸Šï¼Œå·¦ï¼Œå³ï¼Œä¸‹
  * ä¸Šï¼Œå·¦ -> å‡ºç•ŒâŒ
  * ä¸‹(1,0) -> å¯ä»¥ï¼Œæˆ‘ä»¬æ ‡ä¸€ä¸ª `1`ï¼Œè¡¨ç¤ºå¯ä»¥ä¸€æ­¥èµ°åˆ°è¿™ä¸ªç‚¹
    * æ”¾å…¥é˜Ÿåˆ—-->`å·²ç»å‘ç°ä½†è¿˜æ²¡æœ‰æ¢ç´¢ï¼ˆæ’é˜Ÿï¼‰`
  * å³ -> å¢™âŒ
3. å¼€å§‹æ¢ç´¢ (1, 0)--> ä¸Šï¼Œå·¦ï¼Œå³ï¼Œä¸‹
  * ä¸Š -> å·²æ¢ç´¢âŒ
  * å·¦ -> å‡ºç•ŒâŒ
  * ä¸‹ -> å¯ä»¥ï¼Œæˆ‘ä»¬æ ‡ä¸€ä¸ª `2`ï¼Œè¡¨ç¤ºå¯ä»¥ä¸¤æ­¥èµ°åˆ°è¿™ä¸ªç‚¹
    * æ”¾å…¥é˜Ÿåˆ—(2, 0)-->`å·²ç»å‘ç°ä½†è¿˜æ²¡æœ‰æ¢ç´¢ï¼ˆæ’é˜Ÿï¼‰`
  * å³ -> å¯ä»¥ï¼Œæˆ‘ä»¬æ ‡ä¸€ä¸ª `2`ï¼Œè¡¨ç¤ºå¯ä»¥ä¸¤æ­¥èµ°åˆ°è¿™ä¸ªç‚¹
    * æ”¾å…¥é˜Ÿåˆ—(1, 1)-->`å·²ç»å‘ç°ä½†è¿˜æ²¡æœ‰æ¢ç´¢ï¼ˆæ’é˜Ÿï¼‰`
4. å¼€å§‹æ¢ç´¢ (2, 0)
  ......å‘ç°å¹¶å…¥é˜Ÿ
5. å¼€å§‹æ¢ç´¢ (1, 1)
  ......å‘ç°å¹¶å…¥é˜Ÿ
6. å¼€å§‹æ¢ç´¢ (x, y)......

**ç»“æŸæ¡ä»¶ï¼š**
* å·²ç»èµ°åˆ°ç»ˆç‚¹
* é˜Ÿåˆ—ä¸ºç©º

**åŸºæœ¬ç¼–ç æµç¨‹ï¼š**

1. å…ˆæŠŠè¿·å®«è¯»è¿›æ¥
2. èµ°è¿·å®«ï¼ˆwalkï¼‰
  * `start` ---> `end`
  * ä»æŸä¸€ç‚¹`å¦‚ï¼š(0, 0)`èµ°åˆ°æŸä¸€ç‚¹`å¦‚ï¼š(5, 4)`
3. ç©ºé™åˆ° `start`ï¼Œæˆ‘ä»¬è¦ç»´æŠ¤å¦å¤–ä¸€ä¸ª `2` ç»´çš„ `slice(steps)`
  * é‡Œé¢æ¯ä¸€æ ¼ä»£è¡¨ä» `start` èµ°äº†å¤šå°‘æ­¥æ‰åˆ°è¿™ä¸€æ ¼
  * `steps`
    * è¿™ä¸ªå¾ˆé‡è¦ï¼Œæœ€åçš„è·¯å¾„å°±æ˜¯ç”¨è¿™ä¸ªå»ºç«‹å‡ºæ¥çš„
4. ä¸€ä¸ªæ ¼å­å®Œæˆæ¢ç´¢çš„éœ€è¦åšä¸¤ä»¶äº‹å„¿
  * æ ¼å­æ”¾å…¥èµ·ç‚¹åˆ°è¾¾å®ƒçš„æ­¥æ•°
  * å°†å‘ç°çš„æ ¼å­æ”¾å…¥é˜Ÿåˆ—

### å¼€å§‹ç¼–ç 

```go
package main

import "fmt"

type point struct {
	x int
	y int
}

// ä¸‹ä¸€ä¸ªç‚¹
func (p point) add(d point) point {
	return point{
		p.x + d.x,
		p.y + d.y,
	}
}

func (p point) at(grid [][]int) (int, bool) {
	// ä¸Šä¸‹è¶Šç•Œ
	if p.x < 0 || p.x >= len(grid) {
		return 0, false
	}
	// å·¦å³è¶Šç•Œ
	if p.y < 0 || p.y >= len(grid[p.x]) {
		return 0, false
	}
	// è¿”å› grid[p.x][p.y] çš„å¥½å¤„ --> æ’å¢™ï¼Œå·²ç»æ¢ç´¢ç­‰ç­‰ç»Ÿç»Ÿæ”¾å¤–å±‚åˆ¤æ–­
	return grid[p.x][p.y], true
}

func walk(maze [][]int, start point, end point) [][]int {
	// ç»´æŠ¤ä¸€ä¸ªä¸ maze ç›¸åŒçš„ Steps Slice
	steps := make([][]int, len(maze))
	for i := range steps {
		steps[i] = make([]int, len(maze[0]))
	}
	// å®šä¹‰ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå¹¶å°†èµ·ç‚¹å…¥é˜Ÿ
	// start: å·²ç»å‘ç°ä½†è¿˜æ²¡æœ‰æ¢ç´¢ï¼ˆæ’é˜Ÿï¼‰
	Q := []point{start}

	// å®šä¹‰ ä¸Šï¼Œå·¦ï¼Œä¸‹ï¼Œå³ å››ä¸ªæ–¹å‘
	dirs := []point{{-1, 0}, {0, -1}, {1, 0}, {0, 1}}

	// ç»å…¸å†™æ³•ï¼Œé˜Ÿåˆ—ä¸ºç©ºï¼Œèµ°è¿·å®«ç»“æŸ
	for len(Q) > 0 {
		cur := Q[0] // è¦æ¢ç´¢çš„ç‚¹
		Q = Q[1:]   // å‡ºé˜Ÿ

		// å››ä¸ªæ–¹å‘æ¢ç´¢
		for _, d := range dirs {
			// ä¸‹ä¸€ç‚¹
			next := cur.add(d)
			// valï¼šç”¨æ¥åˆ¤æ–­åœ¨ maze æ˜¯å¦æ˜¯å¢™(1)
			// ok: ç”¨æ¥åˆ¤æ–­åœ¨ maze æ˜¯å¦è¶Šç•Œ
			val, ok := next.at(maze)
			// æœ‰å¢™ä¸èƒ½æ¢ç´¢ï¼Œè¶Šç•Œä¸èƒ½æ¢ç´¢
			if val == 1 || !ok {
				continue
			}
			// valï¼šç”¨æ¥åˆ¤æ–­ç‚¹åœ¨ steps æ˜¯å¦æ˜¯å€¼ï¼Œæœ‰å€¼è¡¨æ˜è¿™ä¸ªä½ç½®åœ¨ `maze` ä¸­å·²ç»æ¢ç´¢è¿‡äº†
			// ok: ç”¨æ¥åˆ¤æ–­åœ¨ steps æ˜¯å¦è¶Šç•Œ
			val, ok = next.at(steps)
			if val != 0 || !ok {
				continue
			}
			// ä¸‹ä¸€æ¢ç´¢ç‚¹ä¸èƒ½æ˜¯èµ·ç‚¹
			if next == start {
				continue
			}
			curSteps, _ := cur.at(steps)
			// æ ¼å­æ”¾å…¥èµ·ç‚¹åˆ°è¾¾å®ƒçš„æ­¥æ•°
			steps[next.x][next.y] = curSteps + 1
			// å°†å‘ç°çš„æ ¼å­æ”¾å…¥é˜Ÿåˆ—--> å·²ç»å‘ç°ä½†è¿˜æ²¡æœ‰æ¢ç´¢ï¼ˆæ’é˜Ÿï¼‰
			Q = append(Q, next)
		}
	}
	return steps
}

func main() {
	// è¿·å®«
	maze := [][]int{
		{0, 1, 0, 0, 0},
		{0, 0, 0, 1, 0},
		{0, 1, 0, 1, 0},
		{1, 1, 1, 0, 0},
		{0, 1, 0, 0, 1},
		{0, 1, 0, 0, 0},
	}
	// å…¥å£
	start := point{0, 0}
	// å‡ºå£
	end := point{len(maze) - 1, len(maze[0]) - 1}

	steps := walk(maze, start, end)
	for _, row := range steps {
		for _, val := range row {
			// 3ä½å¯¹é½ï¼Œæ‰“å°ç»“æœ
			fmt.Printf("%3d", val)
		}
		fmt.Println()
	}
}

```

è¾“|å‡º|ç»“|æœ|æœ
-|-|-|-|-
0|0|`4`|`5`|`6`
`1`|`2`|`3`|0|`7`
2|0|4|0|`8`
0|0|0|`10`|`9`
0|0|12|`11`|0
0|0|13|`12`|`13`